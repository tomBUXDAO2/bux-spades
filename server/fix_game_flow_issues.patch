--- a/src/index.ts
+++ b/src/index.ts
@@ -1850,6 +1850,9 @@
       // Emit trick complete with the current trick before clearing it
       io.to(game.id).emit('trick_complete', {
         trick: {
           cards: game.play.currentTrick,
           winnerIndex: winnerIndex,
         },
         trickNumber: game.play.trickNumber,
       });
@@ -1860,7 +1863,6 @@
       // Clear the trick immediately for proper game state
       game.play!.currentTrick = [];
       
-      // Save game state after each trick completion
+      // Save game state after each trick completion
       try {
                         // Save game state after each trick completion
                 try {
@@ -1870,7 +1872,7 @@
       } catch (err) {
         console.error('Failed to save game state after trick:', err);
       }
       
-      // Emit immediate game update with cleared trick and updated trick counts
+      // FIXED: Delay the game_update emission until after the animation completes
+      // This prevents the card from disappearing from the table while still in hand
+      setTimeout(() => {
+        // Emit game update with cleared trick and updated trick counts
       const enrichedGame = enrichGameForClient(game);
       console.log('[TRICK DEBUG] Emitting game_update with currentPlayer:', enrichedGame.play?.currentPlayer, 'currentPlayerIndex:', enrichedGame.play?.currentPlayerIndex);
       io.to(game.id).emit('game_update', enrichedGame);
@@ -1880,6 +1882,7 @@
       setTimeout(() => {
         io.to(game.id).emit('clear_trick');
       }, 2000); // 2 second delay to match frontend animation
+      }, 2100); // Slightly longer than animation duration to ensure smooth transition
       
       // If all tricks played, move to hand summary/scoring
       console.log('[HAND COMPLETION DEBUG] Checking hand completion - trickNumber:', game.play.trickNumber);
