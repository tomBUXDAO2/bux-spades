import { v4 as uuidv4 } from 'uuid';
import prisma from './prisma';
import { games } from '../gamesStore';
import type { Game } from '../types/game';

// Update PlayerTrickCount after every trick
export async function updatePlayerTrickCount(gameId: string, roundNumber: number, playerId: string, tricksWon: number) {
  try {
    // Find the actual roundId from database
    const round = await prisma.round.findFirst({
      where: { gameId, roundNumber }
    });
    
    if (!round) {
      console.error(`[DB SCORING ERROR] Round ${roundNumber} not found for game ${gameId}`);
      return;
    }
    
    await prisma.playerTrickCount.upsert({
      where: {
        gameId_roundId_playerId: {
          gameId,
          roundId: round.id,
          playerId
        }
      },
      update: {
        tricksWon,
        lastUpdated: new Date()
      },
      create: {
        id: uuidv4(),
        gameId,
        roundId: round.id,
        playerId,
        tricksWon
      }
    });
    console.log(`[DB SCORING] Updated PlayerTrickCount: ${playerId} has ${tricksWon} tricks in round ${round.id}`);
  } catch (error) {
    console.error(`[DB SCORING ERROR] Failed to update PlayerTrickCount:`, error);
  }
}

// Calculate and store GameScore after each hand using database data
export async function calculateAndStoreGameScore(gameId: string, roundNumber: number) {
  try {
    // Get all round bids for this round
    const round = await prisma.round.findFirst({
      where: { gameId, roundNumber },
      include: { RoundBid: true }
    });
    
    if (!round) {
      console.error(`[DB SCORING ERROR] Round ${roundNumber} not found for game ${gameId}`);
      return null;
    }
    
    // Get current trick counts for this round
    const trickCounts = await prisma.playerTrickCount.findMany({
      where: { roundId: round.id }
    });
    
    // Get previous running totals
    const previousScore = await prisma.gameScore.findFirst({
      where: { gameId },
      orderBy: { roundNumber: 'desc' }
    });
    
    const team1 = [0, 2];
    const team2 = [1, 3];
    
    // Calculate team bids (excluding nil bids)
    let team1Bid = 0, team2Bid = 0;
    let team1Tricks = 0, team2Tricks = 0;
    
    // Get player positions from game
    const game = games.find(g => g.id === gameId);
    if (!game) {
      console.error(`[DB SCORING ERROR] Game ${gameId} not found in memory`);
      return null;
    }
    
    // Calculate team bids and tricks
    for (const roundBid of round.RoundBid) {
      const playerIndex = game.players.findIndex(p => p?.id === roundBid.playerId);
      if (playerIndex === -1) continue;
      
      const trickCount = trickCounts.find(tc => tc.playerId === roundBid.playerId);
      const tricks = trickCount?.tricksWon || 0;
      
      if (team1.includes(playerIndex)) {
        team1Tricks += tricks;
        if (roundBid.bid > 0) { // Regular bid (not nil/blind nil)
          team1Bid += roundBid.bid;
        }
      } else if (team2.includes(playerIndex)) {
        team2Tricks += tricks;
        if (roundBid.bid > 0) { // Regular bid (not nil/blind nil)
          team2Bid += roundBid.bid;
        }
      }
    }
    
    console.log(`[DB SCORING] Round ${roundNumber} - Team 1: bid ${team1Bid}, tricks ${team1Tricks}`);
    console.log(`[DB SCORING] Round ${roundNumber} - Team 2: bid ${team2Bid}, tricks ${team2Tricks}`);
    
    // Calculate team scores using correct nil logic
    let team1Score = 0, team2Score = 0;
    let team1Bags = 0, team2Bags = 0;
    
    // Team 1 scoring
    if (team1Tricks >= team1Bid) {
      team1Score += team1Bid * 10;
      team1Bags = team1Tricks - team1Bid;
      team1Score += team1Bags; // Bags are worth 1 point each
    } else {
      team1Score -= team1Bid * 10;
      team1Bags = 0; // No bags for failed bids
    }
    
    // Team 2 scoring
    if (team2Tricks >= team2Bid) {
      team2Score += team2Bid * 10;
      team2Bags = team2Tricks - team2Bid;
      team2Score += team2Bags; // Bags are worth 1 point each
    } else {
      team2Score -= team2Bid * 10;
      team2Bags = 0; // No bags for failed bids
    }
    
    // Handle nil and blind nil bids
    for (const roundBid of round.RoundBid) {
      const playerIndex = game.players.findIndex(p => p?.id === roundBid.playerId);
      if (playerIndex === -1) continue;
      
      const trickCount = trickCounts.find(tc => tc.playerId === roundBid.playerId);
      const tricks = trickCount?.tricksWon || 0;
      
      if (roundBid.bid === 0) { // Nil bid
        if (tricks === 0) {
          // Successful nil
          if (team1.includes(playerIndex)) team1Score += 100;
          else team2Score += 100;
        } else {
          // Failed nil (set)
          if (team1.includes(playerIndex)) {
            team1Score -= 100;
            // If team already made their bid, failed nil tricks become bags
            if (team1Tricks >= team1Bid) {
              team1Bags += tricks;
              team1Score += tricks;
            }
          } else {
            team2Score -= 100;
            // If team already made their bid, failed nil tricks become bags
            if (team2Tricks >= team2Bid) {
              team2Bags += tricks;
              team2Score += tricks;
            }
          }
        }
      } else if (roundBid.bid === -1) { // Blind nil bid
        if (tricks === 0) {
          // Successful blind nil
          if (team1.includes(playerIndex)) team1Score += 200;
          else team2Score += 200;
        } else {
          // Failed blind nil (set)
          if (team1.includes(playerIndex)) {
            team1Score -= 200;
            // If team already made their bid, failed blind nil tricks become bags
            if (team1Tricks >= team1Bid) {
              team1Bags += tricks;
              team1Score += tricks;
            }
          } else {
            team2Score -= 200;
            // If team already made their bid, failed blind nil tricks become bags
            if (team2Tricks >= team2Bid) {
              team2Bags += tricks;
              team2Score += tricks;
            }
          }
        }
      }
    }
    
    // Calculate running totals
    const team1RunningTotal = (previousScore?.team1RunningTotal || 0) + team1Score;
    const team2RunningTotal = (previousScore?.team2RunningTotal || 0) + team2Score;
    
    // Apply bag penalty to running totals if needed
    let finalTeam1RunningTotal = team1RunningTotal;
    let finalTeam2RunningTotal = team2RunningTotal;
    let finalTeam1Bags = (previousScore?.team1Bags || 0) + team1Bags;
    let finalTeam2Bags = (previousScore?.team2Bags || 0) + team2Bags;
    
    // Apply 10-bag penalty
    if (finalTeam1Bags >= 10) {
      const penaltyApplied = Math.floor(finalTeam1Bags / 10) * 100;
      const bagsRemoved = Math.floor(finalTeam1Bags / 10) * 10;
      finalTeam1RunningTotal -= penaltyApplied;
      finalTeam1Bags -= bagsRemoved;
      console.log(`[DB SCORING] Team 1 bag penalty: -${penaltyApplied}, new total: ${finalTeam1RunningTotal}`);
    }
    
    if (finalTeam2Bags >= 10) {
      const penaltyApplied = Math.floor(finalTeam2Bags / 10) * 100;
      const bagsRemoved = Math.floor(finalTeam2Bags / 10) * 10;
      finalTeam2RunningTotal -= penaltyApplied;
      finalTeam2Bags -= bagsRemoved;
      console.log(`[DB SCORING] Team 2 bag penalty: -${penaltyApplied}, new total: ${finalTeam2RunningTotal}`);
    }
    
    // Store the score in database
    const gameScore = await prisma.gameScore.create({
      data: {
        id: uuidv4(),
        gameId,
        roundNumber,
        team1Score,
        team2Score,
        team1Bags: finalTeam1Bags,
        team2Bags: finalTeam2Bags,
        team1RunningTotal: finalTeam1RunningTotal,
        team2RunningTotal: finalTeam2RunningTotal
      }
    });
    
    console.log(`[DB SCORING] Stored GameScore for round ${roundNumber}:`);
    console.log(`  Team 1: ${team1Score} (total: ${finalTeam1RunningTotal}, bags: ${finalTeam1Bags})`);
    console.log(`  Team 2: ${team2Score} (total: ${finalTeam2RunningTotal}, bags: ${finalTeam2Bags})`);
    
    return gameScore;
  } catch (error) {
    console.error(`[DB SCORING ERROR] Failed to calculate and store game score:`, error);
    return null;
  }
}

// Check if game should end based on database scores
export async function checkGameCompletion(gameId: string): Promise<{ shouldEnd: boolean; winner?: number; reason?: string }> {
  try {
    const latestScore = await prisma.gameScore.findFirst({
      where: { gameId },
      orderBy: { roundNumber: 'desc' }
    });
    
    if (!latestScore) {
      return { shouldEnd: false };
    }
    
    const game = games.find(g => g.id === gameId);
    if (!game) {
      return { shouldEnd: false };
    }
    
    // Check if either team reached max points
    if (latestScore.team1RunningTotal >= game.maxPoints) {
      return { shouldEnd: true, winner: 1, reason: `Team 1 reached ${game.maxPoints} points` };
    }
    
    if (latestScore.team2RunningTotal >= game.maxPoints) {
      return { shouldEnd: true, winner: 2, reason: `Team 2 reached ${game.maxPoints} points` };
    }
    
    // Check if either team reached min points (negative threshold)
    if (latestScore.team1RunningTotal <= game.minPoints) {
      return { shouldEnd: true, winner: 2, reason: `Team 1 reached ${game.minPoints} points` };
    }
    
    if (latestScore.team2RunningTotal <= game.minPoints) {
      return { shouldEnd: true, winner: 1, reason: `Team 2 reached ${game.minPoints} points` };
    }
    
    return { shouldEnd: false };
  } catch (error) {
    console.error(`[DB SCORING ERROR] Failed to check game completion:`, error);
    return { shouldEnd: false };
  }
}
